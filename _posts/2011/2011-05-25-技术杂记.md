---
layout: post
title: 技术杂记
category: java,技术
tags: [java,技术]
---

# 技术杂记 #

## Hessian ##
昨天发现有这样的好东西！研究了一下，发现很不错！介绍个大家学习学习，而且这个资料比较少，希望能让大家入门了！

### 定义一个接口 ###

``` java 
package study.hessian;  
  
public interface IBasic {      
    
    public String hello();      
   
    public Person getPerson();      
     
}    
```

### 一个接口的实现类 ###

``` java 
package study.hessian;  
   
public class BasicService implements IBasic {      
  private String hello= "Hello, Vincent";      
     
  public String hello()      
  {      
    return hello;      
  }      
     
    public Person getPerson() {      
        Person person = new Person();      
        person.setColor("Yello");      
        person.setLength("176cm");      
        person.setName("vincent");      
        return person;      
    }      
}    
```
### 定义一个实体 ###
必须实现序列化接口，因为要通过网络传输

``` java 
package study.hessian;  
  
import java.io.Serializable;  
  
public class Person implements Serializable{  
  
    private static final long serialVersionUID = 3276641446246664L;  
    private String name;  
    private String length;  
    private String color;  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public String getLength() {  
        return length;  
    }  
  
    public void setLength(String length) {  
        this.length = length;  
    }  
  
    public String getColor() {  
        return color;  
    }  
  
    public void setColor(String color) {  
        this.color = color;  
    }  
  
}  
``` 

### web.xml文件 ###

``` xml 
<?xml version="1.0" encoding="UTF-8"?>  
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
    <welcome-file-list>  
        <welcome-file>index.jsp</welcome-file>  
    </welcome-file-list>  
    <servlet>  
        <servlet-name>hello</servlet-name>  
        <servlet-class>  
            com.caucho.hessian.server.HessianServlet  
        </servlet-class>  
        <init-param>  
            <param-name>home-class</param-name>  
            <param-value>study.hessian.BasicService</param-value>  
        </init-param>  
        <init-param>  
            <param-name>home-api</param-name>  
            <param-value>study.hessian.IBasic</param-value>  
        </init-param>  
    </servlet>  
  
    <servlet-mapping>  
        <servlet-name>hello</servlet-name>  
        <url-pattern>/hello</url-pattern>  
    </servlet-mapping>  
</web-app>  
``` 

### 客户端的类 ###

``` java
package study.hessian;  
  
import com.caucho.hessian.client.HessianProxyFactory;  
  
public class BasicClient {      
    public static void main(String []args)      
        throws Exception      
      {      
        String url = "http://127.0.0.1:8080/WorkTest/hello";      
        HessianProxyFactory factory = new HessianProxyFactory();      
        IBasic basic = (IBasic) factory.create(IBasic.class, url);  
        System.out.println(basic);  
          Person person   = basic.getPerson();      
          System.out.println("Hello: " + basic.hello());      
        System.out.println("Hello: " + person.toString());      
      }      
}  
```
    String url = http://127.0.0.1:8080/WorkTest/hello;
    WorkTest 工程名字
    在http://hessian.caucho.com 下载一个 hessian.jar文件倒到工程就可以了！

## Java实现验证码 ##

### 编写一个Servlet ###
``` java
import java.awt.Color;  
import java.awt.Font;  
import java.awt.Graphics;  
import java.awt.image.BufferedImage;  
import java.io.ByteArrayOutputStream;  
import java.io.IOException;  
  
import javax.imageio.ImageIO;  
import javax.servlet.ServletException;  
import javax.servlet.ServletOutputStream;  
import javax.servlet.http.HttpServlet;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import javax.servlet.http.HttpSession;  
  
public class CheckCodeServlet extends HttpServlet {  
    private static int WIDTH = 60;  
    private static int HEIGHT = 20;  
  
    public char[] generateCheckCode() {  
        // 定义验证码的字符表  
        String chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";  
        char[] rands = new char[4];  
        for (int i = 0; i < 4; i++) {  
            int rand = (int) (Math.random() * 36);  
            rands[i] = chars.charAt(rand);  
        }  
        return rands;  
    }  
  
    public void drawRands(Graphics g, char[] rands) {  
        g.setColor(Color.BLACK);  
        g.setFont(new Font(null, Font.ITALIC | Font.BOLD, 18));  
        // 在不同的高度上输出验证码的每个字符  
        g.drawString("" + rands[0], 1, 17);  
        g.drawString("" + rands[1], 16, 15);  
        g.drawString("" + rands[2], 31, 18);  
        g.drawString("" + rands[3], 46, 16);  
    }  
  
    public void drawBackground(Graphics g) {  
        // 画背景  
        g.setColor(new Color(0xDCDCDC));  
        g.fillRect(0, 0, WIDTH, HEIGHT);  
        // 随机产生120个干扰点  
        for (int i = 0; i < 120; i++) {  
            int x = (int) (Math.random() * WIDTH);  
            int y = (int) (Math.random() * HEIGHT);  
            int red = (int) (Math.random() * 255);  
            int green = (int) (Math.random() * 255);  
            int blue = (int) (Math.random() * 255);  
            g.setColor(new Color(red, green, blue));  
            g.drawOval(x, y, 1, 0);  
        }  
    }  
  
    public void doGet(HttpServletRequest request, HttpServletResponse response)  
            throws ServletException, IOException {  
        HttpSession session = request.getSession();  
        response.setContentType("image/jpeg");  
        ServletOutputStream sos = response.getOutputStream();  
  
        // 设置浏览器不缓存此图片  
        response.setHeader("Pragma", "No-cache");  
        response.setHeader("Cache-Control", "no-cache");  
        response.setDateHeader("Expires", 0);  
  
        // 创建内存图像并获得其图形上下文  
        BufferedImage image = new BufferedImage(WIDTH, HEIGHT,  
                BufferedImage.TYPE_INT_RGB);  
        Graphics g = image.getGraphics();  
  
        // 产生随机的验证码  
        char[] rands = generateCheckCode();  
  
        // 产生图像  
        drawBackground(g);  
        drawRands(g, rands);  
  
        // 结束图像的绘制过程,完成图像  
        g.dispose();  
  
        // 将图像输出到客户端  
        ByteArrayOutputStream bos = new ByteArrayOutputStream();  
        ImageIO.write(image, "JPEG", bos);  
        byte[] buf = bos.toByteArray();  
        response.setContentLength(buf.length);  
        sos.write(buf);  
        bos.close();  
        sos.close();  
  
        // 将当前验证码存入到session中  
        session.setAttribute("checkCode", new String(rands));  
        System.out.println(session.getAttribute("checkCode"));  
    }  
  
    public void doPost(HttpServletRequest request, HttpServletResponse response)  
            throws ServletException, IOException {  
        doGet(request, response);  
    }  
}  
```

### 编写一个html页面 ###
``` html 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">  
<html>  
  <head>  
    <title>test.html</title>  
      
    <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">  
    <meta http-equiv="description" content="this is my page">  
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">  
      
    <!--<link rel="stylesheet" type="text/css" href="./styles.css">-->  
    <script type="text/javascript">  
        function ajaxMethod(cid){  
            document.getElementById(cid).setAttribute("src",null);  
            //加上随机数的目的是为了每次都改变url 让浏览器不要加载缓存  
            var svalue = "/JsParserXML/servlet/CheckCodeServlet?id=" + Math.random();  
            document.getElementById(cid).setAttribute("src",svalue);                  
        }  
        function colorblue(id){  
            document.getElementById(id).color="blue";  
        }  
        function colorblack(id){  
            document.getElementById(id).color="black";  
        }  
    </script>  
  </head>  
    
  <body>  
        <font size="2">验证码 :</font>   
        <img id="checkCodeImage" src="/JsParserXML/servlet/CheckCodeServlet" style="cursor:pointer" onclick="javascript:ajaxMethod('checkCodeImage');"/>  
        <a style="cursor:pointer" onclick="javascript:ajaxMethod('checkCodeImage');"><font id="fontId" size="2"><u onmouseover="colorblue('fontId');" onmouseout="colorblack('fontId');">看不清换一个</u></font></a>  
  </body>  
</html> 
```

## 流媒体传输常识 ##

   流式传输定义很广泛，现在主要指通过网络传送媒体（如视频、音频）的技术总称。其特定含义为通过 Internet 将影视节目传送到PC机。实现流式传输有两种方法：实时流式传输（Realtime streaming）和顺序流式传输（progressive streaming）。一般说来，如视频为实时广播，或使用流式传输媒体服务器，或应用如RTSP的实时协议，即为实时流式传输。如使用HTTP服务器， 文件即通过顺序流发送。采用那种传输方法依赖你的需求。当然，流式文件也支持在播放前完全下载到硬盘。 

### 顺序流式传输 ### 

　　顺序流式传输是顺序下载，在下载文件的同时用户可观看在线媒体，在给定时刻，用户只能观看已下 载的那部分，而不能跳到还未下载的前头部分，顺序流式传输不象实时流式传输在传输期间根据用户连接的速度做调整。由于标准的HTTP服务器可发送这种形式 的文件，也不需要其他特殊协议，它经常被称作HTTP流式传输。顺序流式传输比较适合高质量的短片段，如片头、片尾和广告，由于该文件在播放前观看的部分 是无损下载的，这种方法保证电影播放的最终质量。这意味着用户在观看前，必须经历延迟，对较慢的连接尤其如此。对通过调制解调器发布短片段，顺序流式传输 显得很实用，它允许用比调制解调器更高的数据速率创建视频片段。尽管有延迟，毕竟可让你发布较高质量的视频片段。顺序流式文件是放在标准HTTP 或 FTP服务器上， 易于管理，基本上与防火墙无关。顺序流式传输不适合长片段和有随机访问要求的视频，如：讲座、演说与演示。它也不支持现场广播，严格说来，它是一种点播技 术。 

### 实时流式传输 ### 

　　实时流式传输指保证媒体信号带宽与网络连接配匹，使媒体可被实时观看到。实时流与HTTP流式 传输不同，他需要专用的流媒体服务器与传输协议。实时流式传输总是实 时传送，特别适合现场事件，也支持随机访问，用户可快进或后退以观看前面或后面的内容。理论上，实时流一经播放就可不停止，但实际上，可能发生周期暂停。 实时流式传输必须配匹连接带宽，这意味着在以调制解调器速度连接时图象质量较差。而且，由于出错丢失的信息被忽略掉，网络拥挤或出现问题时，视频质量很 差。如欲保证视频质量，顺序流式传输也许更好。实时流式传输需要特定服务器，如：QuickTime Streaming Server、RealServer与Windows Media Server。这些服务器允许你对媒体发送进行更多级别的控制，因而系统设置、管理比标准HTTP服务器更复杂。实时流式传输还需要特殊网络协议， 如：RTSP (Realtime Streaming Protocol)或MMS (Microsoft Media Server)。这些协议在有防火墙时有时会出现问题，导致用户不能看到一些地点的实时内容。

## 几种嵌入视频播放器插件的classid 值 ##

### 一、Windows Media Player： ###

#### 1、Windows Media Player 7 及更高版本： ####
    classid=clsid: 6bf52a52-394a-11d3-b153-00c04f79faa6
    codebase=http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=7.0

#### 2、Windows Media Player 6.4： ####
    classid=clsid: 22d6f312-b0f6-11d0-94ab-0080c74c7e95
    codebase=http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,5,715

#### 3、Windows Media Player 6 以前更老的版本： ####
    classid=clsid:05589FA1-C356-11CE-BF01-00AA0055595A
    codebase=http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=5,1,52,701

### 二、Adobe Flash—-flash播放器 ###
    classid=clsid: d27cdb6e-ae6d-11cf-96b8-444553540000
    codebase=http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,19,0

### 三、Adobe Shockwave Player ###
    classid=clsid:166B1BCA-3F9C-11CF-8075-444553540000 
    codebase=http://download.macromedia.com/pub/shockwave/cabs/director/sw.cab#version=7,0,2,0

### 四、real player播放 Real Video ###
    classid=clsid:cfcdaa03-8be4-11cf-b84b-0020afbbccfa
    codebase=无

### 五、Apple Quicktime ###
    classid=clsid: 02bf25d5-8c17-4b23-bc80-d3488abddc6b
    codebase=http://www.apple.com/qtactivex/qtplugin.cab
 
当然，这些因为flv的出现，已经不再重要了！flv可以真正的跨平台，跨浏览器！

## Linux+Lucene+Tomcat+OpenEjb发布细节 ##

细节1：首先在linux系统上先查看ulimit -a

    vr:~# ulimit -a  
    core file size          (blocks, -c) 0  
    data seg size           (kbytes, -d) unlimited  
    scheduling priority             (-e) 0  
    file size               (blocks, -f) unlimited  
    pending signals                 (-i) 32768  
    max locked memory       (kbytes, -l) 32  
    max memory size         (kbytes, -m) unlimited  
    open files                      (-n) 1024  
    pipe size            (512 bytes, -p) 8  
    POSIX message queues     (bytes, -q) 819200  
    real-time priority              (-r) 0  
    stack size              (kbytes, -s) 8192  
    cpu time               (seconds, -t) unlimited  
    max user processes              (-u) 32768  
    virtual memory          (kbytes, -v) unlimited  
    file locks                      (-x) unlimited  
    
看到open files 太小了 只有1024

需要改大到20000或者以上，不然会出现too many open files 的异常。属于网络异常。

调整方法 ulimit -n 20000

细节2 ：调大tomcat在 监听端口的连接数，默认是200,添加上 属性 acceptCount=“500” 。修改的文件是./conf/server.xml

细节3 ： openejb 里面的stateless的ejb数量max只有10个，绝对满足不了你的需求，调整大点吧！200个应该可以了！修改的文件是 ./conf/openejb.xml

重启tomcat，就ok了！这些细节配置可能影响到你的系统能否稳定的~！

最好把tomcat的内存调整到 1024mb，因为tomcat会有200个stateless bean，启动的时候需要绑定IP，因为ejb是通过网络的JNDI查找桩对象，如果不绑定IP，而你的电脑又有多个IP，可能在访问的时候一时能正常，一时不能正常。

启动命令 ./catalina.bat run -b 192.168.60.115

## IO流的笔记（一） ##

``` java
import java.io.FileInputStream;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.OutputStream;  
import java.net.HttpURLConnection;  
import java.net.URL;  
  
public class GetClassTest {  
      
    public static void main(String[] args) throws IOException {  
        /*远程拉文件*/  
        URL url = new URL("http://192.168.61.115/js/Ajax.js");  
        new GetClassTest().getFileByURL(url, "Test.js");  
          
        /*本地拉文件*/  
        new GetClassTest().getFileByNative("E:/BOSS/SVN_Work/boss/web/js/Ajax.js", "Test.js");  
          
    }  
      
    public void getFileByURL(URL url,String outputString) throws IOException{  
        HttpURLConnection connection =  (HttpURLConnection) url.openConnection();  
        connection.connect();  
          
        if (connection.getResponseCode() != 200) {  
            return;  
        }  
          
        //OutputStream os = response.getOutputStream(); 这个写法是可以提供网络下载的 response 是httpservletresponse  
        OutputStream os = new FileOutputStream(outputString);  
        InputStream is = connection.getInputStream();  
  
        byte[] r = new byte[1024];  
        int len = 0;  
        while ((len = is.read(r)) > 0) {  
            os.write(r, 0, len);  
        }  
        is.close();  
        os.flush();  
        os.close();  
          
        connection.disconnect();  
    }  
      
    public void getFileByNative(String filePath,String outputString) throws IOException{  
        InputStream is = new FileInputStream(filePath);  
        OutputStream os = new FileOutputStream(outputString);  
        byte[] r = new byte[1024];  
        int len = 0;  
        while ((len = is.read(r)) > 0) {  
            os.write(r, 0, len);  
        }  
        is.close();  
        os.flush();  
        os.close();  
    }  
}  
```

## 开发应该注意的细节 ##

web开发方式多种多样，我们应该注意些什么问题呢？我我知道我今天不能完全总结出来，因为我不是神！但是我能把我现在想到的问题总结出来，剩下没有总结的会不断补上，不求100%的完整，只求能给自己留一下一个笔记。

### 页面开发： ###

1.你的javascript能不能兼容各大浏览器，这个兼容问题请参考w3c。

2.网页控件是否对其，是否长短一样！做到一个整洁的页面其实不简单！

3.样式问题，这个和设计者的审美观相连，但求做到大众化就好，总不能让人看了就想吐！

4.为了减轻压力，会不会多考虑使用ajax，在使用ajax的时候要注意安全问题。

5.页面一些文本控件一定要注意sql注入，如果方式特别注意二进制，八进制，十六进制的注入，因为注入的人不一定用源码注入，可能通过转换后的格式注入，直接对数据库的字典表进行扫描并且更新某些表的操作！

6.多考虑用户的使用习惯，按钮的摆放，重要内容的摆放（一般靠左）,菜单的摆放（一般靠左）。一个文本域的大小，考虑你数据库这个字段一般多大，用户使用的时候尽量让他们写得更舒服！

### 代码： ###

1.现在流行面向对象，代码是否应该完全的面向对象呢？完全面向对象会将代码切得十分零碎，假如我们在一个成熟的系统上面开发，我们尽量寻找一些系统有的公共方法，没必要重复制造轮子，如果系统没有，我们就需要考虑要不要做成公共的方法，因为这个方法不一定有必要公共。假如我们是重新开发一个系统，我们就要先写代码，完成第一次开发后讨论将代码进行重构，螺旋式开发。

2.事务问题，这个有很多的观点，这里我只说我自己的观点，我不一定是对的，但是至少我感觉可以才写上去。事务无非写在代码或者写在数据库的存储过程，2个方法都各有优点，但是我感觉写在数据库的存储过程会快些，但是适合的系统不能太多人用，也就是说小型的系统可以使用数据库的存储过程做事务，这样的速度会特别快，而且修改方便。大型的系统需要分压，把事务写在代码上，压力会在web服务器，当然我们有多台web服务器，可以进行分压。

如果你想说数据库多台可以分压，我就疑问数据库的数据同步问题，不能做到事实是一件非常不好的事情。正如现在的搜索引擎一样，我发现也没有能做到事实的，只能做到一个时间段更新一次。其实搜索引擎的索引文件和我们的数据库是同一个意思，也许将来我们不用数据库了，直接使用索引搜索。（ps：不知道会不会出现新的语言呢？）

3.代码对齐，注释问题，日志问题都很重要。特别是日志，好的日志会让我们知道系统的运行是否正常，最坏的打算，就算数据库被破坏，我们还有日志，我们还可以恢复，顶多停一段时间，总比数据全部丢失要好！

4.数据的表现，有些批量显示的数据我们不应该select 字段 from 表 就出来了，我们应该多想想，需要排序么？用户想看到的是什么顺序的数据！

监控系统，未知？正在研究？

未完，待续！ 

## Java代码如何处理异常 ##

很多时候，我们对异常的处理就会使用简单的try-catch 然后catch到Exception 怎么处理呢？我们应该养成这样的习惯！

见识使用两个类分别继承 与 Exception --> ContextException 和 RuntimeException --> OperationException

在自己的异常里面定义两个基本参数（可以根据自己的业务需求定义更多的参数），int code,Exception e 这样在catch 到异常的时候就可以根据 code 去判断这是什么异常，然后 e 是用来打印日志的！这样处理异常，会让代码更容易维护，更容易知道错误的地方！

``` java 
public class OperationException extends Exception {  
    public int code;  
    public Exception e;  
  
    public OperationException(int code) {  
        this.code = code;  
    }  
  
    public int getCode() {  
        return code;  
    }  
  
    public void setCode(int code) {  
        this.code = code;  
    }  
  
    public Exception getE() {  
        return e;  
    }  
  
    public void setE(Exception e) {  
        this.e = e;  
    }  
  
}  
```
``` java
public class Demo {  
  
    /** 
     * @author Vincent 
     */  
    public static void main(String[] args) {  
        Demo demo = new Demo();  
        try {  
            demo.demo(3);  
            System.out.println("运行成功...");  
        } catch (OperationException e) {  
            if(e.getCode() == 1001 ){  
                System.out.println(" i == 1 的异常");  
            }else if(e.getCode() == 1002 ){  
                System.out.println(" i == 2 的异常");  
            }  
        }  
    }  
      
    public void demo(int i) throws OperationException{  
        if( i == 1 ){  
            /* 在这样的情况抛出一个 i == 1 的 代号为 1001 的异常*/  
            throw new OperationException(1001);  
        }else if( i == 2){  
            /* 在这样的情况抛出一个 i == 2 的 代号为 1002 的异常*/  
            throw new OperationException(1002);  
        }  
    }  
  
}  
```  

## java反射---我之见解 ##

最近在做一个项目，开始就没打算使用反射，但是做着做着，发现有很多代码相同！感觉很郁闷，还有很多地方需要运行时才定义的类型，这让我不禁想起了反射，开始只是用一点，然后发现使用反射代码少了，循环多了！很多地方不用写死一个类型，可以使用反射去获取源对象，越做就感觉越好用，甚至连对象封装我都放弃了apache的BeanUtils，自己去写一个封装的方法，可能性能和优势都不够别人强，但是爆出异常至少我可以控制到！这个是使用框架无法做到的！

所以我觉得，作为一个优秀的程序员，需要懂得反射，会用反射，如果作为一个架构师，需要精通反射！有了反射可以让代码更少，让代码的复用性更高更容易维护！而且会减少模块和模块之间的耦合，进一步做到了低耦合高内聚！

``` java
public class DemoBean {  
    private String name;  
    private String engName;  
    private int age;  
    private String dept;  
    private String address;  
    private String phone;  
    private String info;  
    private String desc;  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public String getEngName() {  
        return engName;  
    }  
  
    public void setEngName(String engName) {  
        this.engName = engName;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
    public String getDept() {  
        return dept;  
    }  
  
    public void setDept(String dept) {  
        this.dept = dept;  
    }  
  
    public String getAddress() {  
        return address;  
    }  
  
    public void setAddress(String address) {  
        this.address = address;  
    }  
  
    public String getPhone() {  
        return phone;  
    }  
  
    public void setPhone(String phone) {  
        this.phone = phone;  
    }  
  
    public String getInfo() {  
        return info;  
    }  
  
    public void setInfo(String info) {  
        this.info = info;  
    }  
  
    public String getDesc() {  
        return desc;  
    }  
  
    public void setDesc(String desc) {  
        this.desc = desc;  
    }  
  
}  
```
 
``` java
import java.lang.reflect.Field;  
import java.lang.reflect.InvocationTargetException;  
import java.lang.reflect.Method;  
import java.util.HashMap;  
import java.util.Iterator;  
import java.util.Map;  
import java.util.Set;  
  
public class Demo {  
    public static void main(String[] args) throws SecurityException,  
            NoSuchFieldException, NoSuchMethodException,  
            IllegalArgumentException, IllegalAccessException,  
            InvocationTargetException {  
        DemoBean2 db = new DemoBean2();  
        merge(db, getMap());  
        System.out.println(db.getAge());  
        System.out.println(db.getEngName());  
        System.out.println(db.getDept());  
        System.out.println(db.getInfo());  
        System.out.println(db.getAddress());  
        System.out.println(db.getPhone());  
    }  
  
    public static void merge(Object bean, Map<String, Object> map)  
            throws SecurityException, NoSuchFieldException,  
            NoSuchMethodException, IllegalArgumentException,  
            IllegalAccessException, InvocationTargetException {  
        Set<String> set = map.keySet();  
        Iterator<String> it = set.iterator();  
        while (it.hasNext()) {  
            String fieldName = it.next();  
            Field f = bean.getClass().getDeclaredField(fieldName);  
            String methodName = fieldName.substring(0, 1).toUpperCase()  
                    + fieldName.substring(1, fieldName.length());  
            Method m = bean.getClass().getDeclaredMethod("set" + methodName,  
                    f.getType());  
            m.invoke(bean, map.get(fieldName));  
        }  
    }  
  
    public static Map<String, Object> getMap() {  
        Map<String, Object> map = new HashMap<String, Object>();  
        map.put("engName", "vincent");  
        map.put("age", 12);  
        map.put("dept", "Boss");  
        map.put("address", "中国北京");  
        map.put("phone", "12450358357");  
        map.put("info", "this is infomation");  
        return map;  
    }  
}  
``` 
利用反射去封装一个实体,这样无论你在map里面放入多少个元素都和可以完整的封装到实体里面，用别的方法就比较难实现了！

## logic-iterator用法 ##

``` html
<%@ page language="java" pageEncoding="ISO-8859-1"%>  
<%@taglib uri="http://java.sun.com/jstl/core_rt" prefix="c" %>  
<%@taglib prefix="logic" uri="/WEB-INF/struts_tld/struts-logic.tld" %>  
<%  
    java.util.ArrayList<String> list = new java.util.ArrayList<String>();  
    list.add("aa");  
    list.add("bb");  
    list.add("cc");  
    list.add("dd");  
    session.setAttribute("list",list);  
 %>  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">  
<html>  
    <head>  
    </head>  
  
    <body>  
        <c:set var="index" value="0" />  
        <logic:iterate id="aa" name="list" >  
            <span id="${index}">${aa }</span>  
            <c:set var="index" value="${index+1}" />  
        </logic:iterate>  
        <script type="text/javascript">  
            var a = document.getElementById('0').innerHTML;  
            var b = document.getElementById('1').innerHTML;  
            if(a == b){  
                document.getElementById('0').innerHTML = 'a == b';  
            }else {  
                document.getElementById('1').innerHTML = 'a != b';  
            }  
        </script>  
    </body>  
</html>  
 ```

## 精简之美 ##

有一条阶乘的问题，就是怎么去写才能让代码最少，最精简！我想了很久，发现使用递归是最精简的写法！

``` java
public class Test {  
 public static void main(String[] args) {  
  System.out.println(fact2(7));  
 }  
   
 /* 递归写法 */  
 public static int fact(int n){  
  if( n == 0)  
   return 1;  
  else  
   return n*fact(n-1);  
 }  
   
 /* 非递归写法 */  
 public static int fact2(int n){  
  int sum = 1;  
  while( n >= 1){  
   sum *= n;  
   n -= 1;  
  }  
  return sum;  
 }  
}  
``` 

``` ruby  
# 非递归  
def fact2(n)  
  sum = 1  
  while(n >= 1)  
    sum *= n  
    n -= 1  
  end  
  return sum  
end  
  
# 递归  
def fact(n)  
    if n == 0  
          1  
    else  
          n * fact(n-1)  
    end  
end  
  
puts fact(7)  
``` 

无论是Java 还是 Ruby 精简的代码看上去才是让人最赏心悦目的！ 

## 一个MIDlet的入门例子 ##
``` java
import javax.microedition.lcdui.Display;  
import javax.microedition.lcdui.TextBox;  
import javax.microedition.midlet.MIDlet;  
import javax.microedition.midlet.MIDletStateChangeException;  
  
public class First extends MIDlet {  
    private Display display;  
    public First() {  
        // TODO Auto-generated constructor stub  
    }  
      
    /* destroy doing */  
    protected void destroyApp(boolean arg0) throws MIDletStateChangeException {  
          
    }  
  
    /* pause doing */  
    protected void pauseApp() {  
          
    }  
  
    /* start doing */  
    protected void startApp() throws MIDletStateChangeException {  
        display=Display.getDisplay(this);  
  
        TextBox t=new TextBox("Demo App","欢迎使用O-O手机",256,0);  
  
        display.setCurrent(t);  
    }  
  
}  
``` 

上面代码是利用了eclipseme插件在eclipse上面开发的，加入了WTK2.5.2

eclipseme 在网上可以找到它的官方

WTK2.5.2在sun公司的官方可以下载 

## JSF入门例子 ##
首先去 http://java.sun.com/javaee/javaserverfaces/download.html 下载jsf的标准类库，这是sun公司发布的一套类库！当然还有apache的myfaces等，暂时先用标准的类库去操作！

用myeclipse6.0去搭建一个web的工程

然后开始编写一个登录的例子

### 首先编写web.xml文件 ###

``` xml  
<?xml version="1.0" encoding="UTF-8"?>  
<web-app version="2.5"   
    xmlns="http://java.sun.com/xml/ns/javaee"   
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee   
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">  
  
    <display-name>JSF</display-name>  
    <context-param>  
    <param-name>javax.faces.CONFIG_FILES</param-name>  
    <param-value>/WEB-INF/faces-config.xml</param-value>  
    </context-param>  
  
    <servlet>  
        <servlet-name>Faces Servlet</servlet-name>  
        <servlet-class>  
            javax.faces.webapp.FacesServlet  
        </servlet-class>  
        <load-on-startup>1</load-on-startup>  
    </servlet>  
  
    <servlet-mapping>  
        <servlet-name>Faces Servlet</servlet-name>  
        <url-pattern>*.jsf</url-pattern>  
    </servlet-mapping>  
</web-app>  
 ```

### 再编写jsf的配置文件 faces-config.xml ###

``` xml
<?xml version="1.0"?>  
 <!DOCTYPE faces-config PUBLIC  
 "-//Sun Microsystems, Inc.//DTD JavaServer Faces Config 1.0//EN"  
 "http://java.sun.com/dtd/web-facesconfig_1_0.dtd">  
  
 <faces-config>  
    <navigation-rule>  
        <from-view-id>/index.jsp</from-view-id>  
        <!-- 返回值控制跳转页面 -->  
        <navigation-case>  
             <from-outcome>success</from-outcome>  
            <to-view-id>/welcome.jsp</to-view-id>  
        </navigation-case>  
        <navigation-case>  
             <from-outcome>fail</from-outcome>  
            <to-view-id>/index.jsp</to-view-id>  
        </navigation-case>  
    </navigation-rule>  
  
    <managed-bean>  
        <managed-bean-name>user</managed-bean-name>  
         <managed-bean-class>  
             com.vincent.jsf.demo.UserBean  
         </managed-bean-class>  
        <managed-bean-scope>request</managed-bean-scope>  
    </managed-bean>  
 </faces-config>  
 ```

### 编写一个 UserBean 的类 ###

``` java 
package com.vincent.jsf.demo;  
  
import javax.faces.event.ActionEvent;  
  
public class UserBean {  
    private String name;  
    private String password;  
    private String outCome;  
    private String errMessage;  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public String getPassword() {  
        return password;  
    }  
  
    public void setPassword(String password) {  
        this.password = password;  
    }  
  
      
    public String getOutCome() {  
        return outCome;  
    }  
  
    public void setOutCome(String outCome) {  
        this.outCome = outCome;  
    }  
  
    public String getErrMessage() {  
        return errMessage;  
    }  
  
    public void setErrMessage(String errMessage) {  
        this.errMessage = errMessage;  
    }  
  
    public void loginIn(ActionEvent e){  
        System.out.println(name);  
        System.out.println(password);  
        if(name != null && name.equals("vincent")){  
            outCome = "success";  
        }else{  
            errMessage = "用户名错误";  
            outCome = "fail";  
        }  
    }  
}  
``` 

### 做两个jsp文件 index.jsp 和 welcome.jsp ###

``` jsp
<%@ page language="java" pageEncoding="UTF-8"%>  
<%@taglib uri="http://java.sun.com/jsf/core" prefix="f" %>  
 <%@taglib uri="http://java.sun.com/jsf/html" prefix="h" %>  
 <html>  
 <head>  
 <title>第一个JSF程序</title>  
 </head>  
 <body>  
    <f:view>  
        <h:form>  
            <h3>登录</h3>  
            名称：<h:inputText value="#{user.name}"/><p>  
            密码：<h:inputSecret value="#{user.password}"></h:inputSecret><p/>  
            <h:commandButton value="送出" actionListener="#{user.loginIn}" action="#{user.getOutCome}"/>  
            <font color="red"><h:outputText value="#{user.errMessage}"/></font><p>  
        </h:form>  
    </f:view>  
 </body>  
 </html>  
``` 

``` jsp 
 <%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>  
 <%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>  
 <html>  
 <head>  
 <title>第一个JSF程序</title>  
 </head>  
 <body>  
    <f:view>  
        <h:outputText value="#{user.name}"/> 您好！  
        <h3>欢迎使用 JavaServer Faces！</h3>  
    </f:view>  
 </body>  
 </html>  
 ```
 访问 http://localhost:8080/jsf/index.jsf
 
## struts2-入门实例 ##

struts2 传说中很优秀的web框架，融合了webwork之后显得更加优秀！

首先去apache下载它的2.x的jar包，然后利用myeclipse做成这样的目录结构(ps : 相册 struts2.x)

### web.xml ###

``` xml
<?xml version="1.0" encoding="UTF-8"?>  
<web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">  
  
    <display-name>Struts Blank</display-name>  
  
    <filter>  
        <filter-name>struts2</filter-name>  
        <filter-class>org.apache.struts2.dispatcher.FilterDispatcher</filter-class>  
    </filter>  
  
    <filter-mapping>  
        <filter-name>struts2</filter-name>  
        <url-pattern>/*</url-pattern>  
    </filter-mapping>  
</web-app>
```  
### struts.xml ###

``` xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE struts PUBLIC  
    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"  
    "http://struts.apache.org/dtds/struts-2.0.dtd">  
  
<struts>  
    <constant name="struts.devMode" value="true" />  
    <include file="/config/example.xml" />  
  
    <!-- Add packages here -->  
  
</struts>
```  

### example.xml ###

``` xml 
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE struts PUBLIC  
"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"  
"http://struts.apache.org/dtds/struts-2.0.dtd">  
<struts>  
    <package name="example" namespace="/example"  
        extends="struts-default">  
        <action name="HelloWorld"  
            class="example.HelloWorld">  
            <result name="SUCCESS">/example/HelloWorld.jsp</result>  
        </action>  
    </package>  
</struts>  
```
 
### HelloWorld.java ###

``` java
package example;  
  
public class HelloWorld {  
    private String name;  
  
    public String execute() {  
        System.out.println(name);  
        return "SUCCESS";  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
      
      
}  
```

### NameCollector.jsp ###

``` jsp
<%@ page contentType="text/html; charset=UTF-8"%>  
<%@ taglib prefix="s" uri="/struts-tags"%>  
<html>  
    <head>  
        <title>Name Collector</title>  
    </head>  
    <body>  
        <h4>  
            Enter your name  
        </h4>  
        <s:form action="HelloWorld">  
            <s:textfield name="name" label="Your name" />  
            <s:submit />  
        </s:form>  
    </body>  
</html>  
```

### HelloWorld.jsp ###

``` jsp 
<%@ page language="java" pageEncoding="ISO-8859-1"%>  
<%@ taglib prefix="s" uri="/struts-tags"%>  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">  
<html>  
  <head>  
    <title>My JSP 'HelloWorld.jsp' starting page</title>  
      
    <meta http-equiv="pragma" content="no-cache">  
    <meta http-equiv="cache-control" content="no-cache">  
    <meta http-equiv="expires" content="0">      
    <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">  
    <meta http-equiv="description" content="This is my page">  
    <!-- 
    <link rel="stylesheet" type="text/css" href="styles.css"> 
    -->  
  
  </head>  
    
  <body>  
    Hello <s:property value="name"/>  
  </body>  
</html>  
```  

## 日期处理笔记 ##
获取上个月

``` java 
java.text.SimpleDateFormat df = new java.text.SimpleDateFormat("yyyy-MM");  
java.util.GregorianCalendar gc = (java.util.GregorianCalendar) Calendar.getInstance();    
gc.setTime(new java.util.Date());    
gc.set(Calendar.DAY_OF_MONTH, 1);    
String day_first = df.format(gc.getTimeInMillis()-24*60*60*1000);    
System.out.println(day_first);  
 ```

## Properties里面的一些系统值 ##
当我们需要求出一些系统参数的时候，需要使用到Properties这个类，如果我们通过System.getProperties()直接打印出来，会看到许多数据

``` txt
java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition, sun.boot.library.path=D:\Program Files\Java\jdk1.5.0_16\jre\bin, java.vm.version=1.5.0_16-b02, java.vm.vendor=Sun Microsystems Inc., java.vendor.url=http://java.sun.com/, path.separator=;, java.vm.name=Java HotSpot(TM) Client VM, file.encoding.pkg=sun.io, sun.java.launcher=SUN_STANDARD, user.country=CN, sun.os.patch.level=Service Pack 2, java.vm.specification.name=Java Virtual Machine Specification, .........................................  
``` 

细心的程序员会发现他们都是以key=value成对出现的，所以我们可以通过System.getProperty()获取到我们需要的

例如，user.home,

os.name,

user.dir

值得注意的地方应该是当我们在运行一般的Java Project 的时候获取到的user.dir是当前文件的dir，但是如果我们是一个web工程，那么我们的user.dir就是web容器的路径了，所以当运行web的时候，我们要获取当前类路径我们想需要用另一种方法：

``` java 
UpLoadFilePath.class.getResource("UpLoadFilePath.class").getPath()；
```  
这样子就可以求出当前文件的路径，在自己分析一下字符串就可以求出当前的类路径了！  

## JPA ##
      JPA 全称 Java Persistence API ，是Sun公司定义的一套规范，这套规范有多种实现，用得比较多的是Hibernate的实现和Oracle的实现。两种实现对比一下，Hibernate-entitymanager是开源的，而Oracle的toplink是sun公司官方推荐不过需要收费！当然除了这两个实现还有Apache组织的实现等， 简单介绍完毕。

       这里我主要使用hibernate+Jboss做例子

       hibernate-entitymanager 在 www.hibernate.org

       Jboss  在 www.jboss.org

官方都可以下到

 

写JPA首先要配置jboss服务器的连接池，先介绍一下JBoss服务器的目录结构

    jboss-4.2.2GA
    --bin
    --client
    --docs
        |--examples
                 |--jca
    --lib
    --server
         |--default
                  |--deploy
                  |--lib

有些目录我没有列出来，我只列出了这次内容需要使用到的目录

首先要在jca目录下将mysql-ds.xml，拷贝到deploy目录下面，并且打开修改为

``` xml 
<?xml version="1.0" encoding="UTF-8"?>  
  
<!-- $Id: mysql-ds.xml 63175 2007-05-21 16:26:06Z rrajesh $ -->  
<!--  Datasource config for MySQL using 3.0.9 available from:  
http://www.mysql.com/downloads/api-jdbc-stable.html  
-->  
  
<datasources>  
  <local-tx-datasource>  
    <jndi-name>MySqlDS</jndi-name>  
    <connection-url>jdbc:mysql://localhost:3306/test</connection-url>  
    <driver-class>com.mysql.jdbc.Driver</driver-class>  
    <user-name>root</user-name>  
    <password>root</password>  
    <exception-sorter-class-name>org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter</exception-sorter-class-name>  
    <!-- should only be used on drivers after 3.22.1 with "ping" support  
    <valid-connection-checker-class-name>org.jboss.resource.adapter.jdbc.vendor.MySQLValidConnectionChecker</valid-connection-checker-class-name>  
    -->  
    <!-- sql to call when connection is created  
    <new-connection-sql>some arbitrary sql</new-connection-sql>  
      -->  
    <!-- sql to call on an existing pooled connection when it is obtained from pool - MySQLValidConnectionChecker is preferred for newer drivers  
    <check-valid-connection-sql>some arbitrary sql</check-valid-connection-sql>  
      -->  
  
    <!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml -->  
    <metadata>  
       <type-mapping>mySQL</type-mapping>  
    </metadata>  
  </local-tx-datasource>  
</datasources>  
``` 

在mysql的驱动拷贝到server-default-lib目录下面

这样服务器的配置就完成了！

在MyEclipse里面建立一个EJB的工程，建议使用MyEclise6.0以上的开发工具，将Hibernate-entitymanager的lib导入工程，在jboss-4.2.2GA-client 下面找到jboss-ejb3.x.jar和jbossall-client.jar 这两个jar文件也导入工程里面，工程的环境就搭建好了！

代码我就使用附件上传，不多！不过要注意jndi.properties和META-INF目录下面的persistence.xml 这两个文件的写法就可以了！

[工程下载](http://cg4a83.mail.163.com/app/wp/doGetFile.jsp?sid=zBpsFhppvgWOBuksoAppDPyMQyobyEJx&mode=download&mid=421:xtbBpQxZfU0vHMHOSwABs2)

## 注意Java的误区 ##

``` java 
import java.util.ArrayList;  
/*误区一：注意写代码的规范，要真写出这样的代码，估计你很难检查出来*/  
public class Test {  
    public static void main(String[] args) {  
        ArrayList al = new ArrayList();  
        al.add(1);  
        al.add(2);  
        al.remove(0);  
        al.add(3);  
        al.remove(1);  
        al.add(4);  
        al.remove(2);  
        al.add(5);  
        al.add(6);  
        al.remove(3);  
        System.out.println(al);  
    }  
}  

```

此结果很多人在运行之前不知道！ 

## 项目使用条形码 ##
首先要去[http://barcode4j.sourceforge.net/](http://barcode4j.sourceforge.net/) 下载一个它的专属jar包，那个版本都可以，这里介绍的是version2.0的版本。

一般它有2种用法，一种是生成条形码的图片，那样可以直接生成图片，在jar包里面的example下面有例子，这里就不作介绍了；另一种用法是在web开发里面使用的，通过jar包里面提供的BarcodeServlet。在web开发里面会使用到三个jar文件，barcode4j,commons-cli-1.0.jar和avalon-framework-4.2.0.jar

只要你建立一个web工程，导入三个jar包，编写web.xml

``` xml
<servlet>  
    <servlet-name>BarcodeServlet</servlet-name>  
    <servlet-class>org.krysalis.barcode4j.servlet.BarcodeServlet</servlet-class>  
</servlet>  
<servlet-mapping>  
    <servlet-name>BarcodeServlet</servlet-name>  
    <url-pattern>/barcode</url-pattern>  
</servlet-mapping>
```  
### 编写一个index.jsp文件 ###

``` html
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>  
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">  
<html>  
    <head>  
        <title>My JSP 'index.jsp' starting page</title>  
        <meta http-equiv="pragma" content="no-cache">  
        <meta http-equiv="cache-control" content="no-cache">  
        <meta http-equiv="expires" content="0">  
        <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">  
        <meta http-equiv="description" content="This is my page">  
        <!-- 
    <link rel="stylesheet" type="text/css" href="styles.css"> 
    -->  
    </head>  
  
    <body>  
        <table border="1">  
            <tr>  
                <td>  
                    <h1>  
                        code39  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=JCN090008381&type=code39&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        code128  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=0123456789&type=code128&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        Codabar  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=0123456789&type=codabar&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
            </tr>  
            <tr>  
                <td>  
                    <h1>  
                        intl2of5  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=01234567890540&type=intl2of5&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        upc-a  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=012345678912&type=upc-a&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        ean-13  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=123456789234&type=ean-13&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        ean-8  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=20123451&type=ean-8&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
            </tr>  
  
            <tr>  
                <td>  
                    <h1>  
                        postnet  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=01234567890540&type=postnet&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        royal-mail-cbc  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=012345AS678912&type=royal-mail-cbc&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        pdf417  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=200123457893&type=pdf417&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
                <td>  
                    <h1>  
                        datamatrix  
                    </h1>  
                    <img  
                        src="<%=request.getContextPath()%>/barcode?msg=20123451&type=datamatrix&fmt=jpeg"  
                        height="100px" width=300px />  
                </td>  
            </tr>  
            <tr>  
                <td>  
                    <img src="<%=request.getContextPath()%>/barcode?msg=JCN090008381"/>  
                </td>  
                <td><img src="<%=request.getContextPath()%>/barcode?msg=JCN090008381&type=code39&fmt=jpeg&height=1cm&hrfont=Arial&res=100"/></td>  
                <td><img src="<%=request.getContextPath()%>/barcode?msg=JCN090008381&type=code128&fmt=jpeg&height=1cm&hrfont=Arial&res=100"/></td>  
                  
            </tr>  
        </table>  
    </body>  
</html>  
```
 关于<%=request.getContextPath()%>/barcode? 后面的参数我确实要好好将解释一下
    
    type=code128,  类型  （标准） 还有很多其它的例如 code39
    msg=12345,   内容
    height=2.5cm,  条形码高度
    mw=0.5mm,   条形码斑马线的距离
    wf=2,    还没知道
    qz=10mw,    边空白的距离
    hrp=bottom   JCN090008381 在下面
    hrp=top    JCN090008381 在上面
    fmt=jpeg   图片格式 一般最好使用这个格式，其它格式可能某些浏览器不支持
    hrpattern   
    hrfont   字体类型
    hrsize   
    gray
    res    默认100 改变图片的整体大小
    
## 某网站系统升级遇到的问题 ##

某网站前端系统升级，开发机器使用win2003，浏览器测试IE7，firefox，chromium。上线后陆续碰到的问题。

1. 有些用户使用win 98和2000，访问页面不正常。

2. 有些用户使用IE6，绿色浏览器，360等，访问页面不正常。

访问页面不正常主要出现在，js提交不成功，翻页乱码，翻页没数据，cookie保存的数据不能被清除。

还有其他问题陆续补充！    

## 研究"关于提高BOSS系统安全性"的问题 ##

对于处理这个问题，领导给我了几个要求：

    现在boss系统，很多页面都存在安全隐患，例如知道链接，可能就可以访问权限之外的数据。 
    研究一种方法，给每个访问者不同的密钥，通过解密的方式来访问页面。 
    可以参照CTI原来加密的做法，或者提出更好的方式。 

方法的要求： 

    1、实施简单，尽量不要增加太多的工作量。 
    2、实现权限的管理（例如特殊通道）。 
    3、有较好的扩展性，以便将来需要嵌入更好的功能保留接口。 
    4、加密和解密不能失真。

需要注意：

    1.密钥包含（时间+员工编码+IP）
    2.在头文件做加密信息处理。
    3.框架生成时将加密信息附加在URL后面
    4.BOSS系统和其他系统不一样，我们就算是同一类型的账号，也有很多不同的权限，所以每个人的URL都必须唯一。因为公司的权限是网状，这个网相当复杂。
    5.我们应该考虑到上线的步骤。尽可能做到无缝上线。
    
## 邮件发送时，请不要忘记检测邮件格式 ##

``` java
public static boolean checkEmail(String email){
  Pattern p = Pattern.compile("\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*"); 
         Matcher m = p.matcher(email); 
         boolean b = m.matches(); 
         if(b) { 
             //System.out.println("有效邮件地址"); 
             return true;
         } else { 
             //System.out.println("无效邮件地址");
             return false;
         } 
 }    
 
```

## 近期学习计划(2011/08/31) ## 

1. Oracle 复习一下;

2. Socket 深入研究一下;

3. 线程看看Java5 的新特性;

4. IO和NIO 好好看看;

5.http 头 和 http 协议复习;

6. session 和 cookie;

7. weblogic,webspher.

## Java静态代理 ##

    UserManager
    |                        \
    |                          \
    |                            \
    UserManagerImpl   UserManagerProxyImpl

### UserManager.java ###
``` java
public interface UserManager {
 public void addUser(String userName, String usrePassword);

 public void delUser(String userName, String usrePassword);

 public void modifyUser(String userName, String usrePassword);

 public void findUser(String userName, String usrePassword);
}
```
### UserManagerImpl.java ###
``` java
public class UserManagerImpl implements UserManager {

 @Override
 public void addUser(String userName, String usrePassword) {
  System.out.println("-----------------------UserManagerImpl.addUser------------------------");
 }

 @Override
 public void delUser(String userName, String usrePassword) {
  System.out.println("-----------------------UserManagerImpl.delUser------------------------");
 }

 @Override
 public void findUser(String userName, String usrePassword) {
  System.out.println("-----------------------UserManagerImpl.findUser------------------------");
 }

 @Override
 public void modifyUser(String userName, String usrePassword) {
  System.out.println("-----------------------UserManagerImpl.modifyUser------------------------");
 }

}
``` 
### UserManagerProxyImpl.java ###
``` java 
public class UserManagerProxyImpl implements UserManager{

 private UserManager userManager;
 
 public UserManagerProxyImpl(UserManager userManager){
  this.userManager = userManager;
 }
 
 @Override
 public void addUser(String userName, String usrePassword) {
  this.check();
  this.userManager.addUser(userName, usrePassword);
 }

 @Override
 public void delUser(String userName, String usrePassword) {
  this.check();
  this.userManager.delUser(userName, usrePassword);
 }

 @Override
 public void findUser(String userName, String usrePassword) {
  this.check();
  this.userManager.findUser(userName, usrePassword);
 }

 @Override
 public void modifyUser(String userName, String usrePassword) {
  this.check();
  this.modifyUser(userName, usrePassword);
 }
 
 private void check(){
  System.out.println("----------------check()-------------------");
 }
}
```
### Client.java ###
``` java
public class Client {
 public static void main(String[] args) {
  UserManager um = new UserManagerProxyImpl(new UserManagerImpl());
  um.addUser("userName", "usrePassword");
 }
}
```
### 结论 ###

静态代理是不改变原来的代码架构，加了一个代理类去代理所有的方法，但是这个方法比较笨，如果很多方法在一个类里面那么你就会需要写很多代理的方法。

## Java动态代理 ##
    UserManager
    |                        
    |                          
    |                            
    UserManagerImpl

SecurityHandler 是代理类

### Client.java ###
``` java
import com.s.proxy.UserManager;
import com.s.proxy.UserManagerImpl;

public class Client {
 public static void main(String[] args) {
  SecurityHandler handler = new SecurityHandler();
  UserManager um = (UserManager)handler.newProxy(new UserManagerImpl());
  um.addUser("a", "b");
 }
}
```

### SecurityHandler.java ###
``` java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class SecurityHandler implements InvocationHandler {

 private Object targetObject;
 
 public Object newProxy(Object targetObject){
  this.targetObject = targetObject;
  return Proxy.newProxyInstance(targetObject.getClass().getClassLoader()
     , targetObject.getClass().getInterfaces()
     , this);
 }
 
 @Override
 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  this.check();
  Object ret = null;
  try{
   ret = method.invoke(this.targetObject, args);
  }catch(Exception e){
   e.printStackTrace();
  }
  return ret;
 }

 private void check(){
  System.out.println("----------------check()-------------------");
 }
}
```

UserManager.java 和 UserManagerImpl.java

参考 Java静态代理

## 简单的冒泡算法 ##

``` java
public class MaoPao {
 
 private static int[] array = {6,5,4,3,2,1};
 
 public static void main(String[] args) {
  for(int i = 0 ; i < array.length ; i++){
   for(int j = 1 ; j < array.length - i ; j++){           /*这里减 i 可以减少循环次数，优化程序*/
    if(array[j] < array[j-1]){
     int tmp = array[j];
     array[j] = array[j-1];
     array[j-1] = tmp;
    }
   }
  }
  
  for(int i = 0 ; i < array.length ; i++){
   System.out.println(array[i]);
  }
 }
}

```

## 监控系统开发思考 ##

对计算的监控，在维护服务器的时候非常重要，监控我建议从底层监控，例如计算机的IP层，协议监控，进程监控，数据库连接池80%预警。各种各类的监控我们都需要，那么我们应该怎么去开发，怎么去写，我现在就介绍一下一个用了1年的简单的监控系统。

1. 从IP层进行监控，这一层监控比较简单，我们只需要定时去ping 目标电脑即可，一般主机是windows系统的话，发起一次ping 的动作，系统会返回 Packets: Sent = 4, Received = 4, Lost = 0 (0% loss) 这些信息，4次sent，4次received，0次lost，0%loss，这是最理想的状态，但是一般大型网络很难保证0%loss，所以我们要将loss 分等级，100%loss 是严重，75%，50%，25%，0%之后自己看情况分，毕竟网络的预警可以给我们带来一些提示，为什么会突然出现丢失，是不是网络出现了什么问题，这些问题都值得深思。

``` java
/**
 * @author vincent
 * @category 该类主要用于检测计算机是否存活，网络是否畅通
 * */
public class PingTest{

 private static HashMap<String,Integer> ip_map = new HashMap<String,Integer>();
 /**
  * 初始化IP
  * */
 static {
  System.out.println("初始化............PingTest");
  for(String s : Configuration.ips){
   ip_map.put(s,0);
  }
 }

 public static void main(String[] args) {
  new PingTest().execute();
 }


 /**
  * 检测
  * */
 public void execute(){
  Set<String> ip_list = ip_map.keySet(); 
  Runtime rt = Runtime.getRuntime();
  Process process = null;
  StringBuffer sb = null;
  for (String ip_s : ip_list) {/*循环IP*/
   try {
    process = rt.exec(ip_s);
    InputStream is = process.getInputStream();
    sb = new StringBuffer();
    byte[] r = new byte[1024];
    int len = 0;
    while ((len = is.read(r)) > 0) {
     sb.append(new String(r, 0, len));
    }
    // System.out.println(sb.toString());
    if (sb.toString().contains("(100% loss)")) {/*如果是ping不通就发短信*/
     int count = ip_map.get(ip_s);
     ip_map.put(ip_s, ++count);
     if(count <= 3){/*发送3次短信之后就不发送了*/
      //System.out.println(ip_s + " 需要发短信"+count);
      Message.sendMessage(ip_s.replace(" ", ":")+":stop!time:" + new java.sql.Timestamp(System.currentTimeMillis()).toString().replace(" ", "~"));
     }else{
      System.out.println(ip_s + " 出现问题，已经发送3次短信通知");
     }
    }else{/*正常ping通之后就打印一句话*/
     ip_map.put(ip_s, 0);
     System.out.println(ip_s + " ok!time:"+new java.sql.Timestamp(System.currentTimeMillis()));
    }
    is.close();
   } catch (IOException e) {
    e.printStackTrace();
   }
  }
 }
}
```

2.关于端口检测，是防止电脑能ping 通，但是端口出现异常而造成的问题。我们可以使用apache-net 帮助我们进行监控，但是建议还是从基础出发，通过Soket进行监控即可。

``` java
import java.net.InetSocketAddress;
import java.net.Socket;

public class TelnetTest {
 public static void main(String[] args) {
  try {
   Socket socket = new Socket();
   socket.connect(new InetSocketAddress("192.168.60.11",25), 5000);
   System.out.println("ok");
   socket.close();
  } catch (Exception e) {
   System.out.println(" 连接不上 或者 超时 ");
  }
 }
}
```

3. 当一台服务器运行了多个进程，有些进程没有监听端口，我们只能通过进程检测。

假设我们需要在监控A电脑上面的进程，A电脑是一台linux的机器，我们通过Java代码 调用 ps -ef 的命令将所有的线程查询出来，并且写成一个文件。然后我们的监控服务器通过网络共享的方式去检测该文件是否存在指定的进程，如果不存在就报警。这样子的监控就能保证对每条进程进行很好的监控了。

## 线程的题目 ##

子线程 运行 10次

然后主线程 运行100 次，轮训 子--主 -- 子 --主 50 次

请写出实现类？

``` java
package com.thread;

public class ThreadTest {
 public static void main(String[] args) {

  final Print p = new Print();

  new Thread(new Runnable() {

   @Override
   public void run() {
    for (int i = 1; i <= 50; i++)
     p.print100();
   }

  }).start();

  for (int i = 1; i <= 50; i++)
   p.print10();
 }
}

class Print {

 private int runNum = 10;

 public synchronized void print10() {

  while (runNum != 10) {
   try {
    this.wait();
   } catch (InterruptedException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
   }
  }

  for (int i = 1; i <= 10; i++)
   System.out.println("sub thread print " + i);

  runNum = 100;
  this.notify();

 }

 public synchronized void print100() {

  while (runNum != 100) {
   try {
    this.wait();
   } catch (InterruptedException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
   }
  }

  for (int i = 1; i <= 100; i++)
   System.out.println("main thread print " + i);

  runNum = 10;
  this.notify();
 }
}
```

## 常用排序 ##

1.一般我们排序，都会想到算法，冒泡基本上是用得最多的排序算法。

2.不要忘记 Collections.sort(obj) 方法，它也能排序哦。

## 对象复制工具类 ##
该类的创作灵感：首先我有两个大型的对象需要属性复制，这个复制我知道apache已经有实现类，但是我还是自己封装了一个，然后复制的时候我可以排除某些属性。以达到很好的控制。我现在是规定了必须是同样的class才可以进行复制，如果你们想复制两个不一样class的只要把代码修改一下就可以了，但是复制不一样的class会出现的异常太多，这里暂时不编写。

测试

    10000 次循环  存在break
    第1次：5077107404（纳秒）
    第2次：5058867220（纳秒）
    第3次：5134416226（纳秒）
    第4次：5170925577（纳秒）
    第5次：5122745679（纳秒）


    10000 次循环  不存在break
    第1次：8678000414（纳秒）
    第2次：8798163708（纳秒）
    第3次：8854754246（纳秒）
    第4次：8591999591（纳秒）
    第5次：8668845223（纳秒）

请细心思考为什么要break

``` java
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Timestamp;

public class ObjectUtils {
 public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  Position desc = new Position();
  Position source = new Position();
  source.setId("id");
  source.setAddress("address");
  source.setRegisterdate(new Timestamp(System.currentTimeMillis()));
  String[] exceptAttribute = {"id","address"};
  copyObjectAttribute(desc, source, exceptAttribute);
  System.out.println(desc.getId());
  System.out.println(desc.getAddress());
  System.out.println(desc.getRegisterdate());
 }

 /* 从 source 将值 复制到 desc ，排除了 exceptAttribute 里面的属性，source 和 desc 必须是同一个对象模板 */
 public static void copyObjectAttribute(Object desc, Object source, String[] exceptAttribute) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  if (desc == null || source == null || !desc.getClass().equals(source.getClass())) {
   System.out.println("can't run the copyObjectAttribute,please check the source and desc object!");
   return;
  }

  Method[] desc_methods = desc.getClass().getMethods();
  Method[] source_methods = source.getClass().getMethods();
  int flag = 0;
  for (Method desc_m : desc_methods) {
   if(exceptAttribute != null && exceptAttribute.length > 0){
    for(String ea : exceptAttribute){
     if (desc_m.getName().substring(3, desc_m.getName().length()).toLowerCase().equals(ea)) {
      flag = 1;
      break;//每一次 内循环 只有一次匹配到 if 的条件，所以只要进入if 就可以break 这一次内循环
     }
    }
    if (flag == 1) { flag = 0 ; continue; } /* 如果碰到不用 复制的属性不走下去了，回头吧！ */
   }
   for (Method source_m : source_methods) {
    if (desc_m.getName().startsWith("set")
      && source_m.getName().startsWith("get")
      && source_m.getName().substring(3, source_m.getName().length()).equals(
        desc_m.getName().substring(3, desc_m.getName().length()))) {
     desc_m.invoke(desc, source_m.invoke(source));
     //System.out.println("source method : " + source_m.getName());
     break;//每一次 内循环 只有一次匹配到 if 的条件，所以只要进入if 就可以break 这一次内循环
    }
   }
  }
 }

}
```

## POI使用笔记 ##

1. 到apache 上面下载poi

2.建立工程

3.在src目录下新建一个1.xlsx 的文件

4.导入poi所需求的jar包

     dom4j-1.6.1.jar
     geronimo-stax-api_1.0_spec-1.0.jar
     poi-3.7-20101029.jar
     poi-ooxml-3.7-20101029.jar
     poi-ooxml-schemas-3.7-20101029.jar
     xmlbeans-2.3.0.jar

5.code
``` java 
package com.test;

import java.io.IOException;

import org.apache.poi.openxml4j.exceptions.InvalidFormatException;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;

public class Test01 {
 public static void main(String[] args) throws InvalidFormatException, IOException {
  Workbook wb = WorkbookFactory.create(Test01.class.getResourceAsStream("/1.xlsx"));
  Sheet sheet = wb.getSheetAt(0);
  System.out.println(sheet.getLastRowNum());
  for (Row row : sheet) {
   for (Cell cell : row) {
    System.out.print(cell+"\t\t");
   }
   System.out.println();
  }
 }
}
```

## 设计模式-单例之谜 ##

俗话说：单例学得好，老婆少不了。

既然这样子，我们马上进入单例的学习。

单例总的来说，可以分两种模式：青梅足马型和一见钟情型。

青梅足马型：
``` java
public class Singleton{
 private static Singleton obj = new Singleton();
 private Singleton(){}
 public static Singleton getInstance(){
  return obj;
 }
}
```
从上面的代码可以看出来，基本上一开始就有了，对象的一出生就有了。没得换，和旧社会的青梅足马是不是很像? 

我们可以在 程序初始化创建这种对象，节约系统后期创建对象的时间。但是万一这个对象没有被使用，那就会浪费JVM 的old memory space.

一见钟情型：

type1
``` java
public class Singleton{
 private static Singleton obj;
 private Singleton(){}
 public static synchronized Singleton getInstance(){
  if(obj == null){
   obj = new Singleton();
  }
  return obj;
 }
}
```
type2 
``` java
public class Singleton{
 private volatile static Singleton obj;
 private Singleton(){}
 public static Singleton getInstance(){
  if(obj == null){
   synchronized(Singleton.class){
    if(obj == null){
     obj = new Singleton();
    }
   }
  }
 }
}
```

type1 和 type2 的区别， 就是type1 要锁住整个方法，所消耗的资源相对比type2 多一些，在高并发的系统，我们往往会选择type2 。

type1 可以理解为 约会的时候包场，type2 在约会的时候订桌子，消耗更多，这样子你就明白了吧！